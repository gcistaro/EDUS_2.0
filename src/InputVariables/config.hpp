// Warning! This file is autogenerated from input_schema.json using gen_input_struct.py script
std::string const locked_msg("parameters are locked");

class config_t 
{
    public:
    nlohmann::json const& dict() const
    {
        return dict_;
    }
    nlohmann::json& dict()
    {
        return dict_;
    }
    /// name of the file _tb.dat
    inline auto tb_file() const
    {
        return dict_.at("/tb_file"_json_pointer).get<std::string>();
    }
    inline void tb_file(std::string tb_file__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/tb_file"_json_pointer] = tb_file__;
    }
    /// Fermi energy of the system
    inline auto fermienergy() const
    {
        return dict_.at("/fermienergy"_json_pointer).get<double>();
    }
    inline void fermienergy(double fermienergy__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/fermienergy"_json_pointer] = fermienergy__;
    }
    /// Units used for the Fermi energy of the system
    inline auto fermienergy_units() const
    {
        return dict_.at("/fermienergy_units"_json_pointer).get<std::string>();
    }
    inline void fermienergy_units(std::string fermienergy_units__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/fermienergy_units"_json_pointer] = fermienergy_units__;
    }
    /// Gap value, if we want to open more gap
    inline auto opengap() const
    {
        return dict_.at("/opengap"_json_pointer).get<double>();
    }
    inline void opengap(double gap__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/opengap"_json_pointer] = gap__;
    }
    /// Gap value, if we want to open more gap
    inline auto opengap_units() const
    {
        return dict_.at("/opengap_units"_json_pointer).get<std::string>();
    }
    inline void opengap_units(std::string gap_units__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/opengap_units"_json_pointer] = gap_units__;
    }
    /// If true, we go beyond IPA using HSEX theory
    inline auto coulomb() const
    {
        return dict_.at("/coulomb"_json_pointer).get<bool>();
    }
    inline void coulomb(bool coulomb__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/coulomb"_json_pointer] = coulomb__;
    }
    /// If ipa, non-interactiong particles are considered. If RPA, we consider only the Hartree term for the interaction. If hsex, both Hartree and screened Fock are taken into account.
    inline auto method() const
    {
        return dict_.at("/method"_json_pointer).get<std::string>();
    }
    inline void method(std::string method__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/method"_json_pointer] = method__;
    }
    /// dielectric constant for RK potential
    inline auto epsilon() const
    {
        return dict_.at("/epsilon"_json_pointer).get<double>();
    }
    inline void epsilon(double epsilon__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/epsilon"_json_pointer] = epsilon__;
    }
    /// r0 screening length for RK potential
    inline auto r0() const
    {
        return dict_.at("/r0"_json_pointer).get<std::vector<double>>();
    }
    inline void r0(std::vector<double> r0__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/r0"_json_pointer] = r0__;
    }
    /// Units for r0
    inline auto r0_units() const
    {
        return dict_.at("/r0_units"_json_pointer).get<std::string>();
    }
    inline void r0_units(std::string r0_units__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/r0_units"_json_pointer] = r0_units__;
    }
    /// Dimension of the k grid (R as well) used for the simulation
    inline auto grid() const
    {
        return dict_.at("/grid"_json_pointer).get<std::array<int, 3>>();
    }
    inline void grid(std::array<int, 3> grid__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/grid"_json_pointer] = grid__;
    }
    /// Number of filled bands for the simulation (ideally will be either this of fermienergy
    inline auto filledbands() const
    {
        return dict_.at("/filledbands"_json_pointer).get<int>();
    }
    inline void filledbands(int filledbands__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/filledbands"_json_pointer] = filledbands__;
    }
    /// Time resolution used for propagating Density Matrix
    inline auto dt() const
    {
        return dict_.at("/dt"_json_pointer).get<double>();
    }
    inline void dt(double dt__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/dt"_json_pointer] = dt__;
    }
    /// Units for the Time resolution used for propagating Density Matrix
    inline auto dt_units() const
    {
        return dict_.at("/dt_units"_json_pointer).get<std::string>();
    }
    inline void dt_units(std::string dt_units__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/dt_units"_json_pointer] = dt_units__;
    }
    /// Time steps needed to print in hdf5 and observables
    inline auto printresolution() const
    {
        return dict_.at("/printresolution"_json_pointer).get<int>();
    }
    inline void printresolution(int printresolution__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/printresolution"_json_pointer] = printresolution__;
    }
    /// Time steps needed to print in hdf5 and observables
    inline auto printresolution_pulse() const
    {
        return dict_.at("/printresolution_pulse"_json_pointer).get<int>();
    }
    inline void printresolution_pulse(int printresolution__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/printresolution_pulse"_json_pointer] = printresolution__;
    }
    inline auto gradient_space() const
    {
        return dict_.at("/gradient_space"_json_pointer).get<std::string>();
    }
    /// Initial time of the simulation
    inline auto initialtime() const
    {
        return dict_.at("/initialtime"_json_pointer).get<double>();
    }
    inline void initialtime(double initialtime__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/initialtime"_json_pointer] = initialtime__;
    }
    /// Units for the Time resolution used for Initial time of the simulation
    inline auto initialtime_units() const
    {
        return dict_.at("/initialtime_units"_json_pointer).get<std::string>();
    }
    inline void initialtime_units(std::string initialtime_units__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/initialtime_units"_json_pointer] = initialtime_units__;
    }
    /// Final time of the simulation
    inline auto finaltime() const
    {
        return dict_.at("/finaltime"_json_pointer).get<double>();
    }
    inline void finaltime(double finaltime__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/finaltime"_json_pointer] = finaltime__;
    }
    /// Units for the Time resolution used for Final time of the simulation
    inline auto finaltime_units() const
    {
        return dict_.at("/finaltime_units"_json_pointer).get<std::string>();
    }
    inline void finaltime_units(std::string finaltime_units__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/finaltime_units"_json_pointer] = finaltime_units__;
    }
    /// Solver used for time propagation of the Density Matrix
    inline auto solver() const
    {
        return dict_.at("/solver"_json_pointer).get<std::string>();
    }
    inline void solver(std::string solver__)
    {
        if (dict_.contains("locked")) {
            throw std::runtime_error(locked_msg);
        }
        dict_["/solver"_json_pointer] = solver__;
    }
    /// Order of the Solver used for time propagation of the Density Matrix
    inline auto order() const
    {
        return dict_.at("/order"_json_pointer).get<int>();
    }
    /// Kpath to print the band structure in crystal coordinates 
    inline std::vector<std::vector<double>> kpath()
    {
        return dict_.at("/kpath"_json_pointer).get<std::vector<std::vector<double>>>();
    }
    /// description of all the lasers
    class lasers_t {
    private:
        nlohmann::json& dict_;

    public:
        lasers_t(nlohmann::json& dict__)
            : dict_(dict__)
        {
        }
        auto intensity() const
        {
            return dict_.at("intensity").get<double>();
        }
        auto intensity_units() const
        {
            return dict_.at("intensity_units").get<std::string>();
        }
        auto frequency() const
        {
            return dict_.at("frequency").get<double>();
        }
        auto frequency_units() const
        {
            return dict_.at("frequency_units").get<std::string>();
        }
        auto wavelength() const
        {
            return dict_.at("wavelength").get<double>();
        }
        auto wavelength_units() const
        {
            return dict_.at("wavelength_units").get<std::string>();
        }
        auto polarization() const
        {
            return dict_.at("polarization").get<std::vector<double>>();
        }
        auto t0() const
        {
            return dict_.at("t0").get<double>();
        }
        auto t0_units() const
        {
            return dict_.at("t0_units").get<std::string>();
        }
        auto cycles() const
        {
            return dict_.at("cycles").get<double>();
        }
        bool contains(std::string key__) const
        {
            return dict_.contains(key__);
        }       
        auto phase() const
        {
            return dict_.at("phase").get<double>();
        }

    };
    class lasers_list_t {
    private:
        nlohmann::json& dict_;

    public:
        lasers_list_t(nlohmann::json& dict__)
            : dict_(dict__)
        {
        }
        int size() const
        {
            return dict_.size();
        }
        void append(nlohmann::json& node__)
        {
            dict_.push_back(node__);
        }
    };
    lasers_t lasers(int idx__)
    {
        nlohmann::json::json_pointer ptr("/lasers");
        return lasers_t(dict_.at(ptr / idx__));
    }
    // lasers_t lasers(int idx__) const
    //{
    //     nlohmann::json::json_pointer ptr("/lasers");
    //     return lasers_t(dict_.at(ptr / idx__));
    // }
    lasers_list_t lasers()
    {
        nlohmann::json::json_pointer ptr("/lasers");
        return lasers_list_t(dict_.at(ptr));
    }
    // lasers_list_t lasers() const
    //{
    //     nlohmann::json::json_pointer ptr("/lasers");
    //     return lasers_list_t(dict_.at(ptr));
    // }
private:
protected:
    nlohmann::json dict_;
};
